<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Slient Plant</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mpwang.github.io/"/>
  <updated>2017-08-30T01:44:02.000Z</updated>
  <id>http://mpwang.github.io/</id>
  
  <author>
    <name>Randall Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python重构代码的一些模式</title>
    <link href="http://mpwang.github.io/2017/08/26/python-refactor-patterns/"/>
    <id>http://mpwang.github.io/2017/08/26/python-refactor-patterns/</id>
    <published>2017-08-26T14:02:56.000Z</published>
    <updated>2017-08-30T01:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下介绍一些<code>python idiom</code>，每当你在代码库中看到以下的模式可以参照以下的建议进行重构，让代码变得更加的<code>pythonic</code>，可读性更好，更容易维护。</p>
<p>代码示例Python版本为2.7</p>
<h1 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h1><blockquote class="blockquote-center"><p>需要使用列表的下标时，不要使用C风格的下标遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lst = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line">i = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> lst:</div><div class="line">    <span class="keyword">print</span> i, <span class="string">'--&gt;'</span>, lst[i]</div><div class="line">    i += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># OR</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst)):</div><div class="line">    <span class="keyword">print</span> i, <span class="string">'--&gt;'</span>, lst[i]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line"><span class="keyword">for</span> idx, item <span class="keyword">in</span> enumerate(lst):</div><div class="line">    <span class="keyword">print</span> idx, <span class="string">'--&gt;'</span>, item</div></pre></td></tr></table></figure>
<h1 id="zip-izip"><a href="#zip-izip" class="headerlink" title="zip/izip"></a>zip/izip</h1><blockquote class="blockquote-center"><p>同时遍历两个列表时，不要使用C风格的下标遍历</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lst1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">lst2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(lst1)):</div><div class="line">    <span class="keyword">print</span> lst1[i]</div><div class="line">    <span class="keyword">print</span> lst2[i]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line"><span class="keyword">for</span> lst1_item, lst2_item <span class="keyword">in</span> zip(lst1, lst2):</div><div class="line">    <span class="keyword">print</span> lst1_item</div><div class="line">    <span class="keyword">print</span> lst2_item</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BETTER</span></div><div class="line"><span class="comment"># 不需要在内存中生成包含lst, lst2的第三个列表</span></div><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> izip</div><div class="line"><span class="keyword">for</span> lst1_item, lst2_item <span class="keyword">in</span> izip(lst1, lst2):</div><div class="line">    <span class="keyword">print</span> lst1_item</div><div class="line">    <span class="keyword">print</span> lst2_item</div></pre></td></tr></table></figure>
<h1 id="unpacking-tuple"><a href="#unpacking-tuple" class="headerlink" title="unpacking tuple"></a>unpacking tuple</h1><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span></div><div class="line">y = <span class="number">-10</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line">tmp = x</div><div class="line">x = y</div><div class="line">y = tmp</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line">x, y = y, x</div></pre></td></tr></table></figure>
<h2 id="get-element-from-tuple"><a href="#get-element-from-tuple" class="headerlink" title="get element from tuple"></a>get element from tuple</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">words = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cat'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line">foo = words[<span class="number">0</span>]</div><div class="line">bar = words[<span class="number">1</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line">foo, bar, _ = words <span class="comment"># 使用 _ 如果你不需要这个值</span></div></pre></td></tr></table></figure>
<h1 id="Dict-setdefault-defaultdict"><a href="#Dict-setdefault-defaultdict" class="headerlink" title="Dict.setdefault/defaultdict"></a>Dict.setdefault/defaultdict</h1><blockquote class="blockquote-center"><p>处理字典中key不存在时的默认值</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># group words by frequency</span></div><div class="line">words = [(<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">1</span>, <span class="string">'cat'</span>)]</div><div class="line">frequency = &#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line"><span class="keyword">for</span> freq, word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">if</span> freq <span class="keyword">not</span> <span class="keyword">in</span> frequency:</div><div class="line">        frequency[freq] = []</div><div class="line">    frequency[freq].append(word)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line"><span class="keyword">for</span> freq, word <span class="keyword">in</span> words:</div><div class="line">    frequency.setdefault(freq, []).append(word)</div></pre></td></tr></table></figure>
<p>如果你知道自己在做什么，use <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict" target="_blank" rel="external">defaultdict</a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BETTER</span></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">frequency = defaultdict(list)</div><div class="line"><span class="keyword">for</span> freq, word <span class="keyword">in</span> words:</div><div class="line">    frequency[freq].append(word)</div></pre></td></tr></table></figure></p>
<h1 id="Dict-iteritems"><a href="#Dict-iteritems" class="headerlink" title="Dict.iteritems"></a>Dict.iteritems</h1><blockquote class="blockquote-center"><p>遍历字典</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">words = &#123;<span class="string">'apple'</span>: <span class="number">1</span>, <span class="string">'banana'</span>: <span class="number">2</span>, <span class="string">'cat'</span>: <span class="number">3</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># OK</span></div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">print</span> word, <span class="string">'--&gt;'</span>, words[word] <span class="comment"># 需要计算word的hash值</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GOOD</span></div><div class="line"><span class="keyword">for</span> word, freq <span class="keyword">in</span> words.items():</div><div class="line">    <span class="keyword">print</span> word, <span class="string">'--&gt;'</span>, freq</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BETTER</span></div><div class="line"><span class="comment"># 不需要在内存中生存包含words所有元素的中间结果</span></div><div class="line"><span class="keyword">for</span> word, freq <span class="keyword">in</span> words.iteritems():</div><div class="line">    <span class="keyword">print</span> word, <span class="string">'--&gt;'</span>, freq</div></pre></td></tr></table></figure>
<h1 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h1><blockquote class="blockquote-center"><p>break and nobreak</p>
</blockquote>
<p>使用<code>for...else</code>模式处理遍历列表时搜索符合某些条件的元素<code>break</code>以及搜索不到符合条件元素时的情况。</p>
<p>有些人会认为<code>for...else</code>的语义让人迷惑所以不建议使用，但是正确地使用<code>for...else</code>模式会让代码的结构更加清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># search if a word match some condition exists</span></div><div class="line">words = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cat'</span>]</div><div class="line">condition = <span class="keyword">lambda</span> word: len(word) == <span class="number">1</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DON'T</span></div><div class="line">found = <span class="keyword">False</span></div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">if</span> condition(word):</div><div class="line">        <span class="keyword">print</span> <span class="string">'Found'</span></div><div class="line">        found = <span class="keyword">True</span></div><div class="line">        <span class="keyword">break</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:</div><div class="line">    <span class="keyword">print</span> <span class="string">'Not found'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># DO</span></div><div class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</div><div class="line">    <span class="keyword">if</span> condition(word):</div><div class="line">        <span class="comment"># 处理存在符合condition的元素的情况</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Found'</span></div><div class="line">        <span class="keyword">break</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="comment"># 处理没有符合condition元素的情况</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Not found'</span></div></pre></td></tr></table></figure>
<p><code>else</code>在<code>for...else</code>语法里的语义是<code>如果没有break发生</code>，也即是列表被完全遍历的情况。代码清晰地分成了两部分，你可以明确地看到他们属于同一个结构。</p>
<p><code>for...else</code>语法让人迷惑的地方就是在于<code>else</code>这个名字，根据python核心开发者Raymond Hettinger的说法，如果他们有机会回到过去修改这一语法的话，他们会将<code>else</code>修改为<code>nobreak</code>。</p>
<p>事实上如果不需要处理搜索到符合condition元素时的情况，只需要检查符合condition元素是否存在时，使用<code>any</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">existed = any(map(condition, words))</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> existed:</div><div class="line">    <span class="keyword">print</span> <span class="string">'Not found'</span></div></pre></td></tr></table></figure></p>
<h1 id="try…except…else"><a href="#try…except…else" class="headerlink" title="try…except…else"></a>try…except…else</h1><blockquote class="blockquote-center"><p>分开异常处理与正常情况</p>
</blockquote>
<p><code>try...except</code>语法大家都不陌生，大多数情况下简单地使用地<code>try...except...else</code>语法将臃肿的try block重构就可以让代码的结构更加清晰，将异常处理和正常情况清晰地区分开来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_external_json</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"maybe valid json, maybe some plain text of error"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something_with</span><span class="params">(result)</span>:</span></div><div class="line">    <span class="keyword">print</span> result</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_error</span><span class="params">(e)</span>:</span></div><div class="line">    <span class="comment"># maybe log exception trace</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'Oops'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GOOD</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    result = json.loads(get_external_json())</div><div class="line">    do_something_with(result)</div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">    handle_error(e)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># BETTER</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># 异常可能抛出点</span></div><div class="line">    result = json.loads(get_external_json())</div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">    <span class="comment"># 异常处理</span></div><div class="line">    handle_error(e)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="comment"># 正常情况</span></div><div class="line">    do_something_with(result)</div></pre></td></tr></table></figure>
<p><code>try...except...else</code>这个结构清晰地区分了异常可能的抛出点，异常处理及正常情况三种情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下介绍一些&lt;code&gt;python idiom&lt;/code&gt;，每当你在代码库中看到以下的模式可以参照以下的建议进行重构，让代码变得更加的&lt;code&gt;pythonic&lt;/code&gt;，可读性更好，更容易维护。&lt;/p&gt;
&lt;p&gt;代码示例Python版本为2.7&lt;/p&gt;
&lt;h1 
    
    </summary>
    
    
      <category term="Python" scheme="http://mpwang.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Emacs: 编辑代码与工作效率</title>
    <link href="http://mpwang.github.io/2014/11/12/emcas-and-productivity/"/>
    <id>http://mpwang.github.io/2014/11/12/emcas-and-productivity/</id>
    <published>2014-11-11T16:00:00.000Z</published>
    <updated>2017-08-27T09:17:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><blockquote class="blockquote-center"><p>投资硬件是最简单直接的提高工作效率的方法</p>
</blockquote>
<p>屏幕与键鼠是程序员与电脑之间的输出输入设置，是程序员每天工作接触时间最长的东西，硬件上的提升可以直接提高工作效率以及每天工作的心情。</p>
<h2 id="键盘的选择"><a href="#键盘的选择" class="headerlink" title="键盘的选择"></a>键盘的选择</h2><blockquote><p><a href="http://xahlee.info/kbd/keyboard_switch_mechanisms.html" target="_blank" rel="external">认识薄膜键盘，机械键盘与静电电容键盘</a></p>
</blockquote>
<h3 id="不差钱直接上静电电容键盘"><a href="#不差钱直接上静电电容键盘" class="headerlink" title="不差钱直接上静电电容键盘"></a>不差钱直接上静电电容键盘</h3><h3 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h3><blockquote><p><a href="http://www.zhihu.com/question/23105050" target="_blank" rel="external">先说结论：只选红轴。</a></p>
</blockquote>
<p>键盘这东西最好一步到位一发退烧，不需要反复投入。就机械键盘说来，</p>
<ul>
<li>红轴与黑轴无冲，适合游戏玩家，不同的是按到底所需的力度红轴较小黑轴较大</li>
<li>茶轴与青轴敲击有段落感适合程序员与打字員，青轴所需力度较小但是声音比较吵，茶轴是最多人选择的键芯。<br>综上选择茶轴机械键盘使用，然后可以考虑转向红轴。最重要的是实际试用自己最符合自己的手感</li>
</ul>
<h3 id="人体工程学键盘"><a href="#人体工程学键盘" class="headerlink" title="人体工程学键盘"></a>人体工程学键盘</h3><p>人体工程学键盘的选择见仁见智</p>
<h3 id="HHKB-Happy-Hacking-Keyboard"><a href="#HHKB-Happy-Hacking-Keyboard" class="headerlink" title="HHKB(Happy Hacking Keyboard)"></a>HHKB(Happy Hacking Keyboard)</h3><p>HHKB吹有很多，盲目买HHKB的更多。不引战，只说个人观点：<strong>HHKB不适合重度Emacs用户</strong></p>
<h3 id="键盘布局的选择"><a href="#键盘布局的选择" class="headerlink" title="键盘布局的选择"></a>键盘布局的选择</h3><p>市面上一般键盘所用的都是qwert布局的键盘，虽然有数据表示<a href="https://www.cnblogs.com/zhangshenjia/archive/2012/04/11/qwerty_dvorak_colemak.html" target="_blank" rel="external">dvorak布局</a>可以提高输入效率以及减少手指疲劳，但是较高的上手难度以及训练过渡期间几乎让你不会打字的痛苦都是使用dvorak布局的成本，而且不见得在你掌握新布局之后打字效率会有多大的提升。</p>
<p>作为程序员打字的速度并不是瓶颈，思考速度才是瓶颈，老老实实使用qwert布局就足够了。</p>
<h2 id="多屏幕"><a href="#多屏幕" class="headerlink" title="多屏幕"></a>多屏幕</h2><p><a href="http://www.techug.com/post/programmer-mult-monitors.html" target="_blank" rel="external">多个显示器可以提高程序员的工作效率</a>，减少切换屏幕带来的上下文切换。<br>从一家公司是否给员工配置多个显示器可以看出公司是否尊重程序员的工作。</p>
<p>无脑地使用两个显示器即可提高工作效率，你可能还需要屏幕支架。</p>
<h2 id="使用轨迹球，避免鼠标手"><a href="#使用轨迹球，避免鼠标手" class="headerlink" title="使用轨迹球，避免鼠标手"></a>使用轨迹球，避免鼠标手</h2><p>Logitech M570 聊胜于无</p>
<h1 id="选择正确的编程字体"><a href="#选择正确的编程字体" class="headerlink" title="选择正确的编程字体"></a>选择正确的编程字体</h1><p>windows 下自带的的 Consolas 以及 Mac 下自带的 Monaco 是不错的选择</p>
<p>英文的等宽字体: <a href="https://be5invis.github.io/Iosevka/" target="_blank" rel="external">Iosevka</a>, <a href="https://sourcefoundry.org/hack/" target="_blank" rel="external">Hack</a>, <a href="https://adobe-fonts.github.io/source-code-pro/" target="_blank" rel="external">Source Code Pro</a></p>
<p>中文的等宽字体: 文泉驿等宽微米黑, 微软雅黑</p>
<p>好多人还在使用Windows系统默认的字体，那效果用来看代码实在是惨不忍睹。<br>一旦选择了任一个编程字体，只要15分钟，你几乎不可能还会用回默认的Courier New字体。</p>
<h2 id="Emacs中文与英文对齐"><a href="#Emacs中文与英文对齐" class="headerlink" title="Emacs中文与英文对齐"></a>Emacs中文与英文对齐</h2><p><a href="https://github.com/tumashu/cnfonts" target="_blank" rel="external">chinese-fonts-setup</a> 分别设置Emacs显示中英文时使用不同的字体和大小，帮助你对齐中英文，在我看来在写org文档时这是一个必备的扩展。在使用org-mode table对齐时特别有用。</p>
<h1 id="编辑器-Emacs"><a href="#编辑器-Emacs" class="headerlink" title="编辑器: Emacs"></a>编辑器: Emacs</h1><blockquote class="blockquote-center"><p>Why it’s worth to learn emacs, because the experience will not go away</p>
</blockquote>
<p>Emacs的学习曲线是比较陡峭，但是长期来说投资在Emacs上的时间是值得的。逻辑非常简单：</p>
<ul>
<li>程序员的工作需要进行大量的文本编辑工作</li>
<li>Emacs是非常强大的文本编辑器</li>
<li>所以Emacs可以提高程序员的工作效率</li>
</ul>
<h2 id="key-binding"><a href="#key-binding" class="headerlink" title="key binding"></a>key binding</h2><p>当你在命令行界面使用bash时，你熟悉的<code>ctrl+a</code>跳至行首, <code>ctrl+e</code>跳至行末等快捷键其实就是来源于Emacs，事实上你使用的是bash依赖的<a href="https://cnswww.cns.cwru.edu/php/chet/readline/rluserman.html" target="_blank" rel="external">GNU readline</a>的默认emacs mode。</p>
<p>Mac OS下的cocoa应用默认有emacs按键绑定，你用发现在Mac下使用emacs按键绑定是很自然的事情。</p>
<p>大多数流行的IDE(Eclipse/JetBrains系列/VS Code)都可以设置为 emacs 布局的按键绑定。</p>
<p>熟悉了 emacs 的基本操作快捷键组合后很多地方都可以用得上。</p>
<h2 id="Emacs的编辑哲学"><a href="#Emacs的编辑哲学" class="headerlink" title="Emacs的编辑哲学"></a>Emacs的编辑哲学</h2><p>为什么学习Emacs可以带来好处，因为Emacs会让你对于编辑文本的思考方式不再是基于字符的方法，取而代之的是逻辑上的<code>编辑动作</code>。</p>
<p>从最基本的两个命令（<code>M-x</code>调用命令，<code>ctrl+h</code>查找帮助）开始，你对于日常编辑文本的需求都会变成命令式的。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>排序，选中需要编辑的行，<code>M-x sort-lines</code>.</p>
<p>消除行末多余的空格，选中需要编辑的行，<code>M-x whitespace-cleanup</code>.</p>
<p>光标的移动，字符的删除不再是右移一个字符，删除一个字符。使用<code>ctrl</code>键组合进行基于字符的移动和删除，使用<code>meta</code>键组合进行基于词语的移动和删除。</p>
<ul>
<li><code>ctrl-f</code>右移一个字符 <code>meta-f</code>右移一个词语</li>
<li><code>ctrl-d</code>删除一个字符 <code>meta-d</code>删除一个词语</li>
</ul>
<p>文件内的跳转不再是基于上下左右移动光标，使用<code>ace-jump-mode</code>或者<code>avy-mode</code>你可以快速将光标定位于你想要跳转到的单词。</p>
<p><img src="/images/avy-goto-char.png" alt="jumping around"></p>
<h3 id="showcases"><a href="#showcases" class="headerlink" title="showcases"></a>showcases</h3><p>想到知道 emacs 在日常的编辑文本工作中可以有多用。<a href="http://emacsrocks.com/" target="_blank" rel="external">Emacs Rocks</a>的一系列简短视频可以告诉你。掌握其中一些技巧可以让你在几秒钟内完成你之前也许需要用分钟来计算的任务。</p>
<h3 id="秘密武器：emacs-lisp"><a href="#秘密武器：emacs-lisp" class="headerlink" title="秘密武器：emacs lisp"></a>秘密武器：emacs lisp</h3><p>原生的emacs也许是很好，但是还不够好。Emacs的秘密在于它的扩展可以使用emacs lisp编程语言来写，Emacs 本身相当于emacs lisp的运行环境和解析器。</p>
<p>emacs lisp是一门完善的编程语言，所以程序员们可以方便地编写扩展来集成调用第三方的应用，也许是一个web api也许是一个命令行工具，然后提供给emacs使用。emacs用户可以方便的使用<code>M-x</code>进行调用，相当于将复杂的编辑需求抽象成一个<code>编辑动作</code>。</p>
<h3 id="杀手级应用"><a href="#杀手级应用" class="headerlink" title="杀手级应用"></a>杀手级应用</h3><p>emacs的用户群体已经超出了程序员的范围，现在有许多作家以及科学写作者都开始使用emacs，这些都是emacs的 <a href="http://orgmode.org/" target="_blank" rel="external">org-mode</a> 带来。简单的说来org-mode是一个使用emacs来写笔记的扩展，使用一种类似于markdown的语法。</p>
<p>我自己使用org-mode来组织笔记，编写内容然后生成<a href="https://github.com/fniessen/org-html-themes" target="_blank" rel="external">类似readthedocs风格的文档</a>，编写内容然后<a href="https://github.com/yjwen/org-reveal" target="_blank" rel="external">生成</a>用于<a href="http://lab.hakim.se/reveal-js/#/" target="_blank" rel="external">演讲分享的slides</a>。</p>
<p>emacs的另一个杀手级应用我个人认为是<a href="https://magit.vc" target="_blank" rel="external">magit</a>，在emacs里进行 git 的管理。<br><img src="/images/magit.png" alt="magit"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>提高工作效率，投资硬件是最简单直接生效最快的方法。程序员的日常工作需要大量的文本编辑，emacs很有用，但即使不使用emacs投资时间去掌握一个自己喜欢的编辑器/IDE也是值得的，因为每日的工作大量时间花费在编辑器/IDE里面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h1&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;投资硬件是最简单直接的提高工作效率的方法&lt;/p&gt;
&lt;/block
    
    </summary>
    
    
      <category term="Emacs" scheme="http://mpwang.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>Scott H Young - 为什么要学&#39;没用&#39;的东西？</title>
    <link href="http://mpwang.github.io/2014/10/17/why-learn-useless-things/"/>
    <id>http://mpwang.github.io/2014/10/17/why-learn-useless-things/</id>
    <published>2014-10-16T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.scotthyoung.com/blog/" target="_blank" rel="external">Scott Young</a>是一位我很喜欢的博主，他关注于如何”Learn fast, archieve more”，并且身体力行。他最为人津津乐道的事迹是他的<a href="http://www.scotthyoung.com/blog/mit-challenge/" target="_blank" rel="external">MIT Challenge</a>，他在12个月的时间用一种苦行僧的生活方式，近似专业运动员训练般的高强度学习完成了MIT4年计算机系的课程学习并且通过了测试。</p>
<p><a href="http://www.scotthyoung.com/blog/2014/10/03/learn-useless-things/" target="_blank" rel="external">Why learn “Useless” Things</a>这篇博文分享了他关于为什么要学习“没用”的东西的观点。</p>
<p>大意概括Scott的观点如下：</p>
<ul>
<li>多学习知识能够增加人的启发式思考</li>
<li>因为对新领域知识的缺乏在学习新知识时推断当前学习的知识是否“有用”可能不准确，现在看来没用的知识说不定在日后会派上用场</li>
<li>即使所学的东西真的没用也可以让自己对现实理解的模型更加准确(an accurate model of reality)</li>
</ul>
<p>在与朋友闲聊时谈起在业余时间里评估与接触的各种技术与工具时也曾被人问起：“学这个有什么用？（看这种书有什么用？）不如…”，Scott的观点我是十分赞同的，很好的回答了这种问题，对这个问题也曾思索过但是末能够像Scott那样清楚地表达出来。</p>
<p>在程序员的圈子时也有着什么工具框架API用到的时候再说这种观点，这种观点当然是没错的。但是在遇到新的问题，新的应用场景时如果根本就不知道某种工具/技术/理论的存在，又怎么能够快速找到合适的解决方案呢？很多重复制造出来的轮子就是在这种情况下出现的，所以说博识强记是没错的，博识当然有益，强记不必强求。我自己在最近一个项目里快速地做出了让客户满意的方案，这相当程序得益于我平时阅读博客文章，关注技术动向，遇到有可能用到的工具技术时多加留意并记录下来的习惯。</p>
<p>Steve Job应该是个相当好的例子，他在大学的时候去旁听了看起来与计算机毫无关系的美术字课程并著迷于书法和字体，并对排版产生了浓厚的兴趣。但是这却让他在日后设计苹果个人电脑时设计出了漂亮的字体帮助苹果赢得了市场。有时现在看来没用的知识，说不定日后真的会派上用场。</p>
<p>Scott的最后一个观点有些哲学意味，我却是最赞成与喜欢这个观点。霍金在《大设计》一书中提出的最核心观点就是不存在不依赖模型的理论。多学习一点知识也就会获得多一点对于世界的了解，帮助自己形成一个对于认识世界更加准确的模型。从任何意义上说真是有益的。很多人都会有记录日记与写文章的习惯，这能够帮助人思考，但是并不了解这是为什么。几年前的夏天我翻书柜时发现了一本朋友大学时认知心理学的教材，闲来无事读了一遍。却是让我了解到大脑如何主动接受信息的模型，对知识进行深度加工会加深神经元之间的联接从而加深记忆的理论。在那之后我就养成了读书写读书笔记，学习时做思维导图，使用Pocket与Evernote记录信息的习惯。虽然对于认知科学只是有很浅薄的认识，也许我了解的知识不是最准确或者是绝对意义上正确的，但是在自己的实践过程中行之有效并且有益，这就足够了。</p>
<p>开卷有益，古人诚不我欺。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.scotthyoung.com/blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Scott Young&lt;/a&gt;是一位我很喜欢的博主，他关注于如何”Learn fast, archieve more”，并且身
    
    </summary>
    
    
      <category term="杂谈" scheme="http://mpwang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>编程的技艺, 禅与道</title>
    <link href="http://mpwang.github.io/2014/10/15/chitchat---way-to-programming/"/>
    <id>http://mpwang.github.io/2014/10/15/chitchat---way-to-programming/</id>
    <published>2014-10-14T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><em><a href="http://www.douban.com/note/383111983/" target="_blank" rel="external">原文</a>备份</em></p>
<h1 id="风潮"><a href="#风潮" class="headerlink" title="风潮"></a>风潮</h1><p>题目起得很大,实则谈的只是一点个人的随想. 首先要说文中并不过多涉及技术细节, 本人更不是什么大牛, 只是浅谈自己的一些不成熟并带有个人色彩的认识, 难免会有偏颇之处. 说得不对说得不好, 不要削我.</p>
<p>  现在似乎有一股风潮(或者说近来有越吹越烈的趋势?), 与计算机, 软件开发或编程相关的事物有时会带上一些有宗教或艺术色彩的文字.<br>  来看看一些例子:</p>
<ul>
<li>流行的Javascript框架: Dojo(道场)</li>
<li>流行的PHP框架: Zend PHP(阿维斯陀经注解, 网上解释这是波斯琐罗亚斯德教的圣书, 不太知道应该怎么翻译)</li>
<li>来自外星人科技Lisp家族的杰作: 编程语言Qi(气)以及他的后继者Shen(神)</li>
<li>网站设计领域的著名网站: CSS Zen Garden(CSS禅意花园)</li>
<li>在寓言中暗喻程序员修仙之道的好书: The Tao of programming(编程之道)</li>
<li>硅谷创业之父Paul Graham文集, 畅销书: 黑客与画家</li>
<li>计算机领域中当之无愧的传世经典, 被有些好玩的程序员供起来上香奉养的神书: The Art of Computer Programming(计算机程序设计艺术)</li>
</ul>
<p>他们起这些名字难道是因为名字带上了宗教与艺术相关的词汇之后显得高大上(可以提升逼格)? 答案肯定是否定的. 以上的例子都是饱含智慧结晶的杰作, 不是随随便便被创作出来. 他们的作者似乎都认为编程是一门技艺, 到了相当的程度之后已经是一种境界一种艺术, 追求的事物用中国文化中代表无上境界的文字来说就是: 禅与道. 不闻乎古人有言: 技可进乎道, 艺可通乎神.</p>
<p>  曾经看过MIT关于SICP的远古上课视频, 记忆深刻的是在第一课上那个教授在黑板上写下大大的两个单词: Computer Science, 然后回过头来对学生们说了一句话, 大意是We are going to learn computer science, but it’s not about computer and not about science. 那么究竟是about what? 这么深奥的说法今天还是无法参透啊, 但是可以作为类比吧, 编程究竟又是关于什么的呢. 编程也不仅仅是像程序们自嘲的那样: 我们程序员只是IT民工, 工地搬砖的. 即使是搬砖的, 还是可以有点小追求的.</p>
<p>  在围棋领域中说棋士追求下棋的境界, 人们不会觉得那是他们在扯谈, 而画画, 写作, 作诗, 编曲更是直接与艺术挂钩了. 即使在工程学领域, 作为外行人也曾听闻建筑学上有”建筑是凝固的音乐”这一说法. 它们都有一个共同点, 那就是它们都是一种创造性活动. 而编程作为一种创造性活动, 也是一门技艺. 想写出让人赞叹的程序需要有高超的技巧以及相当的审美观, 如何组织程序, 写出优美的代码, 处理问题逻辑, 考虑系统架构, 设计解决方案就好像画家画画, 作家写书, 同样需要有创造性与灵感以及问题领域的专业知识, 充满挑战与乐趣, 可以称作是工程与美学的结合. 而软件开发更是关于方法论与如何组织人的活动的学问, 研究的是比较玄乎的东西, 不是硬梆梆冷冰冰的计算机硬件. 不同于建筑学此等可以用百年为单位来计数有着悠久历史的学科, 编程或者说是软件开发作为一个行业的历史比较短, 毕竟计算机的大规模普及也只是近代的事情. 关于软件开发没有人知道什么方式是最好的, 所有人都在摸索中前进. 与木匠厨师等职业的经验类似, 前人总结的best practice都是在实践中累积下来的经验之谈, 关于怎么开发软件与编程没有最好的定式, 只有合适实用与否之分. 你没见过厨师做菜的时候切菜要精确到厘米, 下佐料要精确毫克的吧, 即使是有, 这样做出来的菜可以适应不同的食材, 满足不同人的口味吗?</p>
<p>  既然编程是一门技艺, 那么就可以去追求它. 在提升思维质量以及累积领域特定的专业知识之外, 编程这个活动还带有强烈的个人色彩, 其中有得审美因素的影响. 在大量的实践与博识之后, 在编程中就会带上个人的品味. 而品味的形成又会促使技艺的提高, 毕竟口味变刁了, 就会对代码有种精神洁癖或者变成细节控, 逼使自己去让程序变得更符合自己的审美, 在打磨的过程中让程序的品质得到提高. 所以要提高自己的技艺就要努力地形成以及提高自己的品味, 而品味的形成离不开大量的实践与广泛的见识. 写程序与写书本质上非常类似, 不同的是用的是编程语言而不是自然语言. 说起编程语言为什么叫做语言呢, 那是因为在计算机的虚拟世界里, 程序员们在用一种机器可以理解的”语言”来和计算机交流, 告诉他外面的世界是怎么样的, 想要让机器如何运作, 自由地进行创造, 所以称作为”语言”. 但是随着计算机性能的提高以及编译器理论的发展, 在离开与硬件紧密相连的领域, 现在的程序员越来越重视代码的可读性, 编程有着社交属性, 代码还是写给人看的, 翻译成机器指令的工作就交给编译器.</p>
<p>  程序员是工程师, 是problem solver, 问题解决者. 编程员使用工具, 创造工具, 开发软件, 解决问题. 在选择什么工具, 如何创造工具, 如何开发软件, 怎么解决问题的过程中不可避免因为各自审美观与方法论的不同, 各自的答案就会带上个人色彩, 程序员圈子存在着的许多争论就因此而生. 说起来程序员在某些问题上立场鲜明, 与现实中不同党派的支持者政见不同非常类似. 最出名的莫过于Vi与Emacs哪个是最好编辑器之争(顺利一提我是Emacs党, 这篇文章就是在Emacs下写的), 最常见的就各种编程语言支持者之间的争论, 还有类unix vs. Windows, 各种IDE, 解决同个问题的不同库之间的争论等等, 程序员的圈子多姿多彩, 很热闹的啊.</p>
<p>  程序员都是高级的工具使用者与方法论者, 个人觉得实践出真知, 程序员应该抱着实用主义的心态, 不人云亦云地去盲目迷信某种方法论与崇拜某种工具. 在这里说一说个人的一些看法:</p>
<h1 id="大规模应用要用云服务器"><a href="#大规模应用要用云服务器" class="headerlink" title="大规模应用要用云服务器"></a>大规模应用要用云服务器</h1><p>  现在这个云服务器概念非常热门, 谷歌的GAE和亚马逊的AWS就不用说了, 国内的大互联网公司都在开展自己的云服务器服务(新浪云, 阿里云, 腾讯云, 百度云, 就连京东也来掺一脚). 但是不是现在大规模的应用和网站就得要用云服务器了? It depends. 提供一个<a href="http://highscalability.com/blog/2014/7/21/stackoverflow-update-560m-pageviews-a-month-25-servers-and-i.html" target="_blank" rel="external">例子</a>, StackExchange由100多个网站构成，其中包括了Alexa排名第54的StackOverflow(相信这个网站不会陌生)。StackExchang有400万用户，每月5.6亿PV，但只用25台服务器. 它的Windows服务器运行的操作系统版本是Windows 2012 R2，Linux服务器运行Centos 6.4.<br>  5.6亿PV, 25台服务器, 其中有11台运行的Web服务器是微软的IIS. 好像现在一提Web服务器就想起Apache和Nginx, 微软家的IIS不太受欢迎, 但是SO的例子还是说IIS很好用的.</p>
<h1 id="设计模式很牛逼"><a href="#设计模式很牛逼" class="headerlink" title="设计模式很牛逼"></a>设计模式很牛逼</h1><p>  听说面试经常会问到? 诚然了解各种设计模式的概念并在合适的地方使用它是有益的. 但是反对将它捧得太高, 在代码中为了用它而用它, 好像用了设计模式代码就闪闪发光, 品质立马提高. 了解设计模式之后, 反而会破除对它的迷信. 可能有人会提<a href="http://coolshell.cn/articles/3320.html" target="_blank" rel="external">JDK源码里面用了23种设计模式的例子</a>来支持使用设计模式, 但是个人觉得如果你同时了解Java和设计模式, 你就会发现设计模式的使用正是因为Java这种语言比较冗余缺乏表达力, 所以需求显式地使用设计模式来弥补它的不足. 谷歌的研究主管Peter Norvig在一篇1998年的<a href="http://norvig.com/design-patterns/" target="_blank" rel="external">文章</a>中就讨论了动态语言中设计模式, 你可以看到在表达能力比较强的动态语言(还可以推广到一些强类型的函数式语言)中有些设计模式已经被隐式地包含了, 不需要显式地去使用它. 但是理解各种设计模式的概念能够让你在代码中将它们识别出来, 并在必要的合适的地方使用它们来绕过语言的缺憾来达到目的. 就像Head First Design pattern一书说的, 不能去强行修改代码来迎合某种设计模式. 八封一下, 王垠大神在博客中也有说过每当他在代码中清除一个设计模式, 他的代码就变得更加简洁, 更加容易理解(此等境界, 目前仰望中).</p>
<h1 id="哪种编程语言最好"><a href="#哪种编程语言最好" class="headerlink" title="哪种编程语言最好"></a>哪种编程语言最好</h1><p>  各种争论之中, 编程语言之争好像是最激烈的, 到处都可以看到不同语言之间的支持者在掐架. 我是right tool for the right job的支持者, 我不会用C来写生成动态网页的程序, 也不会用Haskell来做系统管理的任务. 如果有一种编程语言是最好的, 那一种编程语言就足够了, 那为什么会有这么多编程语言, 而且新语言还在不停地诞生? 近来比较热门的新语言有Go, Rust, JVM平台上的Ceylon, 编译成C的Nimrod, Erlan平台(BVM)上的Elixir. 答案就是没有最好的编程语言, 只有合适的编程语言. 要完成特定的任务就选用特定的语言与相应的工具. 新语言的出现是因为编程语言的理论研究(像新的类型系统)在发展, 程序员的需求在同样也变化, 而越是热门的语言变化就越慢, 当有人感到现在的语言满足不了需要时, 新的编程语言就被创造出来. 多了解几门语言之后就会发现, 类似的编程概念与经验在各种语言之间是相通的, 不同是各种编程语言各自独有的特性与概念. 八卦一下垠神在博客中有说过他不羡慕各种编程语言的特性, 因为他了解背后编译器是怎么实现它们的, 如果他想要他就可以做出来. 他貌似写过很多编译器当乐趣消遣. 他最近加入了<a href="http://sourcegraph.com/" target="_blank" rel="external">sourcegraph</a>, 其中对Python/Ruby代码的分析就是以他的工作为基础的.</p>
<h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><p>  推荐<a href="http://coolshell.cn/articles/3745.html" target="_blank" rel="external">一篇陈皓的文章</a>. 在我离开之前的公司时, 公司内部有着推广敏捷开发的氛围, 各种各样的讲座,分享会, 在团队内部推行daily stand-up meeting, 但是即使是使用了scrum, story, rapid iteration等概念, 实际工作中字官僚主义横行, 项目的流程还是老一套的样子, 只学其形不见其真意. 个人就不多说, 只想说方法论只是方法论, 能不能够真正去使用这种哲学做出好东西来才是重点. 原教旨主义绝对不可取.</p>
<p>  作为一个普通的程序员, 想成为一个好的程序员还有太多东西需要学习啊.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://www.douban.com/note/383111983/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;备份&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;风潮&quot;&gt;&lt;a href=&quot;#风潮&quot; class=&quot;hea
    
    </summary>
    
    
      <category term="杂谈" scheme="http://mpwang.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp - 想说爱你不容易</title>
    <link href="http://mpwang.github.io/2014/10/14/common-lisp-too-hard-to-love/"/>
    <id>http://mpwang.github.io/2014/10/14/common-lisp-too-hard-to-love/</id>
    <published>2014-10-13T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><em><a href="http://www.douban.com/note/227176889/" target="_blank" rel="external">原文</a>备份</em></p>
<p>前阵子由阮一峰翻译出版的黑客与画家一书似乎激起了不少人对于Lisp的兴趣，出于个人兴趣开始学习Lisp有一段时间，在这里写写自己接触Lisp过程的感想。</p>
<p>Lisp目前有两种主要的dialect: Common Lisp和Scheme。</p>
<p>Scheme<br>对于Scheme我了解不深只用过其中一种dialect: Racket一段时间。Racket有一个非常方便使用的IDE: DrRacket(它附带了很多教学包)以及非常详细的文档说明，学习期间阅读了&lt;<htdp>&gt;和&lt;<the little="" schemer="">&gt;，在了解Lisp的基本思想之后我发现Scheme很难使用(也许是我没有深入学习），来google了一些Scheme和Common Lisp的比较后，我转向了Common Lisp。</the></htdp></p>
<h1 id="Welcome-to-Common-Lisp"><a href="#Welcome-to-Common-Lisp" class="headerlink" title="Welcome to Common Lisp"></a>Welcome to Common Lisp</h1><p>首先来看一下CL的实现列表，看一下还真不少啊，商业收费和免费开源都有，想当初为选择哪一个实现好纠结了一段时间。从好的方面说，有这么多的实现可以让人选择在不同环境下用不同的实现，但是这也带来了问题：社区的分化和库的通用性问题。如果不想代码只能在特定的CL实现上运行，写代码的就要考虑不同CL实现之间的通用性，真是让人头疼。</p>
<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>写CL用什么IDE呢？google一下你会告诉大家都用Emacs+SLIME(少部分人用Vim+SLIMV，但是我相信Lisp程序员最终还是用回到Emacs的怀抱的）。Eclipse也有CL的插件Cusp，但个人感觉并不好用。</p>
<p>来看看典型的Common Lisp工作环境：Emacs + SLIME。<br>你需要掌握：</p>
<ol>
<li>Common Lisp语言</li>
<li>Common Lisp实现的特定细节 比如run time options，实现对于CL的扩展等</li>
<li>Emacs: 包括基本操作，配置初始文件(.emcas or .emacs.d/init.el)设置好SLIME</li>
<li>Paredit: Emcas的extension，用于方便地编辑括号与Lisp表达式</li>
<li>SLIME: 基本操作</li>
</ol>
<p>好吧，并不是说Emacs不好，事实上Emcas+SLIME对于熟练的程序员来说是一个非常强力的编程环境，但是对于没有接触过Emacs的程序员来说，在学习CL的过程中就要同时学习使用Emacs，当然长期来说是有好处，但是这么陡峭的学习曲线已经足于让大多数初学者望而止步。</p>
<p>在这里要提一下，CL是一种比较verbose的语言，有些函数名像multiple-value-bind destructuring-bind是相当的长，没有好的编辑器支持补全功能的话会容易写错。如果没有自动缩进功能的话，lisp code写起来是相当痛苦的。</p>
<h1 id="Modern-Features"><a href="#Modern-Features" class="headerlink" title="Modern Features"></a>Modern Features</h1><p>Lisp是一门相当古老的语言，资深的Common Lisper会告诉你X语言的Y特性可以在Lisp中找到或者通过Z的方式用Lisp实现，但是不可否认的是Common Lisp语言本身缺少对一些现今重要的编程概念/工具的支持。</p>
<p>Common Lisp是在94年完成了标准化，标准给具体的实现留下了相当大的空间，Network programming、Thread、GUI都没有覆盖到。也有人说委员会决定了能够经得起时间考验的核心部分，这些个随时间变动的部分就留给具体的实现。当然这些都可以通过库来支持，但是问题也随之而来，不同的实现+不同的库的选择无疑给程序员带来了难题。(支持不同实现的网络编程库有USOCKET,支持不同实现的线程库有bordeaux-threads，当然它们也不是100% portable的)</p>
<p>由于历史原因，Common Lisp没有在不同的数据结构之间建立一个统一的抽象，因为一开始CL中所有的数据结构都是用List实现的(Use Lists For Everything - ULFE)。CL有两套分别用于List和Vector的函数，一套用于Sequence抽象(List/Vector/String)的函数，一套用于hash-table的函数。在提供不同数据结构统一的抽象这一点上Clojure做得非常好。</p>
<p>缺少字面值hash-table(可以通过reader macro在某种程度上实现)，用过Javascript和Clojure的应该都明白它的强大之处，最近Java7也加入了类似的功能。</p>
<h1 id="Library-amp-Hacker-Culture"><a href="#Library-amp-Hacker-Culture" class="headerlink" title="Library &amp; Hacker Culture"></a>Library &amp; Hacker Culture</h1><p>许多关于CL的抱怨都是关于库的，CL库的数量比较少(相比于Java/C/C++这些主流语言)，而且大多数库都是poor-documented的，缺少详细的说明和例子。写高质量文档对于程序员来说不是件简单轻松的事，而且CL作为一种冷门语言市场上没有太多职位提供给CL程序员，所以也就没有那么人能够得到金钱支持或贡献个人时间来写免费开源的库。我一直听到有人说Lisp是多么多么强大，是的，Lisp非常强大，我知道，但是如果一种编程语言不能容易地与外部世界打交道的话，It doesn’t make sense.</p>
<p>举个例子，用Common Lisp来做XML处理，上Cliki找一下发现有不少啊，我应该用哪一个呢？随便点开看看，发现大多数文档中API的说明不太清楚。而且不是资深的CLer的话也缺少相应的知识来回答下面的问题：哪个库更好？这个库可不可以信任？它有没有bugs? 性能怎么样？它是在活跃的开发中还是已经停止维护了(dead-project)？</p>
<p>为什么会样子，这个现象也与Lisp的Hacker文化有关。Lisp是给Hacker准备的语言，它的强大力量只会在越过了陡峭的学习曲线的某一点后显示出来。因为Common Lisp的表达能力是这么的强大几个人甚至一个smart guy单枪匹马就能够写出足够复杂的程序来，所以大规模的CL hacker合作项目比较少。结果就是每个Hacker都有自己的solution,开发者开发它用来解决的自己工作项目的特定问题，后来开源出来了并不代表它适用于其它用户。Common Lisp的强大反而阻碍了库的标准化，而且Common Lisp也没有类似CPAN for Perl这样的东西存在。</p>
<p>QuickLisp的出现是一个福音，能够解决库的依赖问题以及自己下载相应的库，目前有700个上下的库。</p>
<p>Reddit.com讲述了他们从Common Lisp迁移到Python上的原因，主要也是缺少库的问题。</p>
<h1 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h1><p>在克服了这么多困难之后，你还是选择了Common Lisp，有什么好处呢？</p>
<h2 id="Macro"><a href="#Macro" class="headerlink" title="Macro"></a>Macro</h2><p>Common Lisp的强大的Macro会让你轻松的扩展CL本身来迎合自己的需求，最终形成一个用来解决你的特定问题的DSL。Lisp语言的Macro提供了语法层次上的抽象，让你可以将反复在程式上出现的模式抽象出来，这也是Lisp强大以及和其它语言区分开来的一个原因。</p>
<h2 id="多范式"><a href="#多范式" class="headerlink" title="多范式"></a>多范式</h2><p>Common Lisp的多范式编程可以让你自由地表达自己思想，指令式编程？没有问题，面向对象？没有问题，函数式编程？没有问题，混合着一起使用都没有问题。</p>
<h2 id="REPL（Read-Evaluate-Print-Loop"><a href="#REPL（Read-Evaluate-Print-Loop" class="headerlink" title="REPL（Read-Evaluate-Print-Loop)"></a>REPL（Read-Evaluate-Print-Loop)</h2><p>Lisp为人津津乐道的功能就是它的快速原型开发， 为什么快，因为它全程提供了一个REPL环境，在编译型语言中你需要经历写代码-编译-运行-试错-修改-编译…的流程，而在Lisp语言中你可以实时地更新代码，基本是一边写代码一边在ＲＥＰＬ中测试然后马上修改然后马上得到新的程序然后继续试验，从编写代码到看到代码的输出的循环是如此的短以至于它极高的提高了程序员的生产率（当然这只是理想情况），read-time compile-time run-time基本上是没有区别的（对于macro来说read-time与compile-time有所区别，这里不详谈），这就是用Lisp能够快速开发出软件原型的原因。PG在这篇被CLer反复提到的文章(Beating the Averages)中提到他开发ViaWeb的故事，Common Lisp就是它的秘密武器。可能最后你的程序会迁移到其它语言/平台上，但是你可以快速地构建出软件的雏形。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>Common Lisp真的是让人又爱又恨，不过就算不用CL学习它也用对你有所帮助。新技术层出不穷，而Common Lisp会继续稳定地保持下去，它会继续被用于人工智能领域，研究机构，用于解决复杂度非常高的问题，大公司开发的内部工具。然而对于一般的程序员来说，想用Common Lisp作为自己的首要编程语言真的不太容易。在过去50多年的历史Lisp都没能流行起来，未来也许也不会流行起来。如果问哪种Lisp dialect有可能流行起来的话，Clojure 应该就是其中的佼佼者，作为一门新兴的语言它正在吸引越来越多人的眼光，许多人选择它的程序员有着Rudy/Python/Java/Common Lip的背景，基于JVM平台得益于java ecosystem它天生就解决了库的问题。</p>
<p>PS：对于common lisp还有building system和deployment/delivery的问题没有谈，因为没有用CL做过实际项目这些并不了解，但是也知道其中也有被人诟病的地方。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://www.douban.com/note/227176889/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文&lt;/a&gt;备份&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前阵子由阮一峰翻译出版的黑客与画家一书似乎激起了不少人对于Lisp
    
    </summary>
    
    
      <category term="Lisp" scheme="http://mpwang.github.io/tags/Lisp/"/>
    
      <category term="CommonLisp" scheme="http://mpwang.github.io/tags/CommonLisp/"/>
    
  </entry>
  
  <entry>
    <title>using emacs under mac</title>
    <link href="http://mpwang.github.io/2013/08/10/using-emacs-under-mac/"/>
    <id>http://mpwang.github.io/2013/08/10/using-emacs-under-mac/</id>
    <published>2013-08-09T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在mac下折腾了emacs有一段时间了，写点经验分享一下，顺便一提，mac下cocoa应用全局的emacs按键绑定太舒服了。</p>
<h1 id="安装Emacs"><a href="#安装Emacs" class="headerlink" title="安装Emacs"></a>安装Emacs</h1><p>mac默认安装了emacs的，不过版本比较旧(22.x)，而且只能在终端下使用，这里选用homebrew来安装Emacs, 首先安装<a href="http://brew.sh/" target="_blank" rel="external">homebrew</a>：</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
# --cocoa选项表示安装带图形化界面的emacs
brew install emacs --cocoa
</code></pre><p>安装后brew会提示你可以运行一个命令将emacs 24.3版本链接到/Applications下，这样在应用程序中可以直接双击打开emacs。</p>
<h1 id="Mac下的设置"><a href="#Mac下的设置" class="headerlink" title="Mac下的设置"></a>Mac下的设置</h1><p>使用emacs可能会遇到键位设置的问题，有些键盘上没有option键只有alt键，使用发现alt键不起作用，用来运用<code>M-x</code>的绑定变成了<code>Esc-x</code>。解决方法如下：</p>
<p>在自带的终端下使用: 偏好设置 -&gt; 设置 -&gt; 键盘 -&gt; 勾上使用option键作为meta键</p>
<p>在iterm2下使用:Preferences -&gt; Profiles -&gt; 选择配置文件 -&gt;　keys　-&gt;　在Left/Right option key acts 选项选择 +Esc</p>
<p>在图形化界面下设置需要在emacs初始文件(~/.emacs.d/init.el)中加上：</p>
<pre><code>（when (eq system-type &apos;darwin)
    ;; use option key as meta key
    (setq mac-option-modifier &apos;meta)）
</code></pre><h1 id="以daemon的方式使用emacs"><a href="#以daemon的方式使用emacs" class="headerlink" title="以daemon的方式使用emacs"></a>以daemon的方式使用emacs</h1><p>双击Emacs.app每次都会重新打开一个新的进程来跑emacs, 我更喜欢emacs server + emacs client的方式。用<code>emacs --daemon</code>的方式找开一个后台跑的emacs服务进程，再来emacsclient来连接。</p>
<p>在~/.bash_profile(使用zsh的话就是~/.zshrc)中加入以下alias</p>
<pre><code># 启动emacs后台进程
alias emdaemon=&quot;emacs --daemon&quot;
# 结束emacs后台进程
alias emkill=&quot;emacsclient -e &apos;(kill-emacs)&apos;&quot;
# 新建emacs窗口来编辑文件
alias ec=&quot;emacsclient -c $@&quot;
</code></pre><p>在init.el中加上</p>
<pre><code>(setq window-system-default-frame-alist
  &apos;(
    ;; if frame created on Macintosh Cocoa display
    (ns
     (menu-bar-lines . 1)
     (tool-bar-lines . nil)
     ;; mouse
     (mouse-wheel-mode . 1)
     (mouse-wheel-follow-mouse . t)
     (mouse-avoidance-mode . &apos;exile)
     ;; face
     (font . &quot;Monaco 12&quot;)
     ;; frame size
     (width . 96)
     (height . 60)
     )
    ;; if on term
    (nil
     (menu-bar-lines . 0)
     (tool-bar-lines . 0)
     ;; (background-color . &quot;black&quot;)
     ;; (foreground-color . &quot;white&quot;)
     )
    )
  )
</code></pre><p><a href="http://emacser.com/daemon.htm" title="使用Emacs daemon" target="_blank" rel="external">Emacs中文网这篇文章</a>有更详细的介绍关于emacsclient新建frame设置的介绍。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://kelly-mclaughlin.com/2012/07/27/emacs-daemon.html" target="_blank" rel="external">Setting up the Emacs daemon on OS X</a> </li>
<li><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html" target="_blank" rel="external">Using Emacs as a Server</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在mac下折腾了emacs有一段时间了，写点经验分享一下，顺便一提，mac下cocoa应用全局的emacs按键绑定太舒服了。&lt;/p&gt;
&lt;h1 id=&quot;安装Emacs&quot;&gt;&lt;a href=&quot;#安装Emacs&quot; class=&quot;headerlink&quot; title=&quot;安装Emacs&quot;
    
    </summary>
    
    
      <category term="Emacs" scheme="http://mpwang.github.io/tags/Emacs/"/>
    
      <category term="Mac" scheme="http://mpwang.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>windows下搭建jekyll环境</title>
    <link href="http://mpwang.github.io/2013/08/08/windowsjekyll/"/>
    <id>http://mpwang.github.io/2013/08/08/windowsjekyll/</id>
    <published>2013-08-07T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装Ruby</h1><p>Jekyll是基于Ruby的静态网页生成工具，使用rubyinstaller在windows下安装Ruby. <a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">下载链接</a>.<br>在RubyInstallersArchives下选择合适的版本，64位系统选择(x64)结尾的安装文件。</p>
<p>安装rubyinstaller到D:\Ruby200. 确保安装时在安装界面中选中添加ruby到环境变量的选项。</p>
<h2 id="安装Ruby-DevKit"><a href="#安装Ruby-DevKit" class="headerlink" title="安装Ruby DevKit"></a>安装Ruby DevKit</h2><p><a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">下载链接</a>.在Development Kit下选择合适版本。<br>下回来的文件是个7z的自解压包，解压到D:\Rubydevkit. 运行</p>
<pre><code>ruby dk.rb init
ruby hk.rb install
</code></pre><h1 id="安装jekyll"><a href="#安装jekyll" class="headerlink" title="安装jekyll"></a>安装jekyll</h1><p>理论到直接运行</p>
<pre><code>gem install jekyll
</code></pre><p>就可以安装jekyll了，但是国内的网络环境（你懂的）可能访问不到rubygems，因为<br>rubygem的服务使用了Amazon的云服务器。但是可以使用淘宝的国内镜像：<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>.</p>
<pre><code>$ gem sources --remove https://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org
 # 请确保只有 ruby.taobao.org    
</code></pre><p>先用<code>gem sources -l</code>看看，有些情况下是默认使用<a href="http://rubygems.org" target="_blank" rel="external">http://rubygems.org</a> 而不是<a href="https://rubygems.org" target="_blank" rel="external">https://rubygems.org</a></p>
<pre><code>gem install jekyll
</code></pre><p>下载jekyll</p>
<p>至此jekyll就成功安装并且可以使用了。</p>
<h1 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h1><p>Jekyll使用Pygments在高亮代码，而Pygments是基于Python的。首先安装Python, windows上选用<a href="http://portablepython.com/wiki/PortablePython3.2.1.1/" target="_blank" rel="external">Portable Python</a>。安装到D:\Portable_Python</p>
<p>然后将Portable Python下的App\Scripts和App目录添加到环境变量PATH中。</p>
<h2 id="安装easy-install"><a href="#安装easy-install" class="headerlink" title="安装easy install"></a>安装easy install</h2><p>easy install是Python库的管理软件，类似于gem对于Ruby。我们安装easy install来安装Pygments. <a href="https://pypi.python.org/pypi/setuptools/0.9.8#windows" target="_blank" rel="external">https://pypi.python.org/pypi/setuptools/0.9.8#windows</a>,在python官网这一节介绍中可以找到怎么在windows下安装easy installer的说明，保存<a href="https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py" target="_blank" rel="external">ez_setup.py</a>到本地，比如说D:\</p>
<pre><code>python ez_setup.py
</code></pre><h2 id="安装Pygments"><a href="#安装Pygments" class="headerlink" title="安装Pygments"></a>安装Pygments</h2><pre><code>easy_install Pygments
</code></pre><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>用jekyll写博客少不了用git啦，下载安装<a href="http://msysgit.github.io/" target="_blank" rel="external">msysgit</a>.把安装界面上的选项全部勾上，选项全部默认就好。</p>
<h1 id="第一个模板"><a href="#第一个模板" class="headerlink" title="第一个模板"></a>第一个模板</h1><p>现在jekyll环境已经成功搭建了，下个jekyll bootstrap模板体验一下。在开始菜单中找开git bash.</p>
<pre><code>cd /D
git clone https://github.com/jekyllbootstrap/theme-the-program.git
cd theme-the-program
jekyll serve
</code></pre><p>访问<a href="http://localhost:4040" target="_blank" rel="external">http://localhost:4040</a> </p>
<h1 id="深入了解jekyll"><a href="#深入了解jekyll" class="headerlink" title="深入了解jekyll"></a>深入了解jekyll</h1><p>了解jekyll的配置和各个文件的作用，这篇文章是个很好的入门：<a href="jiyeqian.github.io/2012/07/host-your-pages-at-github-using-jekyll/">基于jekyll的github建站指南</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="http://blog.chengyunfeng.com/?p=437" target="_blank" rel="external">在Windows系统配置Jekyll</a></li>
<li><a href="jiyeqian.github.io/2012/07/host-your-pages-at-github-using-jekyll/">基于jekyll的github建站指南</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装Ruby&quot;&gt;&lt;a href=&quot;#安装Ruby&quot; class=&quot;headerlink&quot; title=&quot;安装Ruby&quot;&gt;&lt;/a&gt;安装Ruby&lt;/h1&gt;&lt;p&gt;Jekyll是基于Ruby的静态网页生成工具，使用rubyinstaller在windows下安装Ruby.
    
    </summary>
    
    
      <category term="Jekyll" scheme="http://mpwang.github.io/tags/Jekyll/"/>
    
      <category term="Ruby" scheme="http://mpwang.github.io/tags/Ruby/"/>
    
      <category term="Git" scheme="http://mpwang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Setup Clojure with SLIME under Emacs</title>
    <link href="http://mpwang.github.io/2012/08/24/setup-clojure-with-slime-under-emacs/"/>
    <id>http://mpwang.github.io/2012/08/24/setup-clojure-with-slime-under-emacs/</id>
    <published>2012-08-23T16:00:00.000Z</published>
    <updated>2017-08-05T11:30:25.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>Updated:</p>
<blockquote>
<p>Swank Clojure is deprecated in favour of nrepl.el</p>
</blockquote>
<p><a href="https://github.com/kingtim/nrepl.el" target="_blank" rel="external">nrepl.el on Github</a></p>
<hr>
<h2 id="Clojure-Side"><a href="#Clojure-Side" class="headerlink" title="Clojure Side"></a>Clojure Side</h2><ul>
<li>Clojure</li>
<li><a href="https://github.com/technomancy/leiningen" target="_blank" rel="external">Leiningen</a></li>
</ul>
<h2 id="Emcas-Side"><a href="#Emcas-Side" class="headerlink" title="Emcas Side"></a>Emcas Side</h2><ul>
<li>Emcas (normally with SLIME installed)</li>
<li>clojure-mode</li>
</ul>
<p>Basically what you need is leiningen on Clojure side and clojure-mode on Emacs side.</p>
<h2 id="Setup-lein"><a href="#Setup-lein" class="headerlink" title="Setup lein"></a>Setup lein</h2><p>Install lein according to the instructions on its index.<br>For lein 2.0 add such line into your global user profile <strong>.lein/profiles.clj</strong>.</p>
<pre><code>{:user {:plugins [[lein-swank &quot;1.4.4&quot;]]}}
</code></pre><p>If you still use lein 1.x, you need such steps.</p>
<ul>
<li>run <code>lein plugin install lein-swank 1.4.4</code></li>
<li>add <code>:dev-dependencies [[lein-swank &quot;1.4.4&quot;]]</code> to your project.clj</li>
</ul>
<h2 id="Setup-clojure-mode"><a href="#Setup-clojure-mode" class="headerlink" title="Setup clojure-mode"></a>Setup clojure-mode</h2><p>Download <a href="https://github.com/technomancy/clojure-mode" target="_blank" rel="external">clojure-mode.el</a>, place it under your emacs load path, add such line to your .emacs file.<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">require</span> 'clojure-mode)</div></pre></td></tr></table></figure></p>
<p>You may install <strong>paredit</strong> and <strong>rainbow-delimiters</strong> to enhance experience for writting Clojure code with Emacs.</p>
<h2 id="Start-up-SLIME-with-Clojure"><a href="#Start-up-SLIME-with-Clojure" class="headerlink" title="Start up SLIME with Clojure"></a>Start up SLIME with Clojure</h2><p>Now</p>
<pre><code>M-x clojure-jack-in
</code></pre><p><strong>Warn: conflit with inferior-lisp-program</strong></p>
<p>Sometimes you work under Emacs with Common Lisp before, you may see Emacs pop up with a window of error message when run the command above. That’s might be caused by the previous compiled swank version for common lisp.</p>
<p><strong>Comment out</strong> your setup for Common Lisp in your .emacs like below and try again:</p>
<pre><code>(setq inferior-lisp-program &quot;sbcl --noinform&quot;)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Updated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Swank Clojure is deprecated in favour of nrepl.el&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/king
    
    </summary>
    
    
      <category term="Lisp" scheme="http://mpwang.github.io/tags/Lisp/"/>
    
      <category term="Clojure" scheme="http://mpwang.github.io/tags/Clojure/"/>
    
      <category term="Emacs" scheme="http://mpwang.github.io/tags/Emacs/"/>
    
  </entry>
  
</feed>
